{
    "sourceFile": "src/components/Vehicles.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1757743664891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1757743780063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,14 +65,14 @@\n   onReachTarget?: () => void;\n }\n \n export const Vehicle = forwardRef<THREE.Group, VehicleProps>(\n-  ({ vehicleType, level, position, targetPosition, isMoving = false, onReachTarget }, ref) => {\n+  ({ vehicleType, level, position, targetPosition, isMoving = false, onReachTarget }, _ref) => {\n     const groupRef = useRef<THREE.Group>(null);\n     const currentPos = useRef(new THREE.Vector3(...position));\n     const targetPos = useRef(targetPosition ? new THREE.Vector3(...targetPosition) : null);\n \n-    useFrame((state, delta) => {\n+    useFrame((_state, delta) => {\n       if (isMoving && targetPos.current && groupRef.current) {\n         const direction = targetPos.current.clone().sub(currentPos.current);\n         const distance = direction.length();\n         \n@@ -114,10 +114,10 @@\n               </mesh>\n               {/* Wheels */}\n               {[-size[0] * 0.4, size[0] * 0.4].map((x, i) =>\n                 [-size[2] * 0.25, size[2] * 0.25].map((z, j) => (\n-                  <mesh key={`${i}-${j}`} position={[x, -size[1] * 0.4, z]} castShadow>\n-                    <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} rotation={[Math.PI / 2, 0, 0]} />\n+                  <mesh key={`${i}-${j}`} position={[x, -size[1] * 0.4, z]} rotation={[Math.PI / 2, 0, 0]} castShadow>\n+                    <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} />\n                     <meshLambertMaterial color=\"#374151\" />\n                   </mesh>\n                 ))\n               )}\n@@ -156,10 +156,10 @@\n                 <boxGeometry args={size} />\n                 <meshLambertMaterial color={vehicleType.color} />\n               </mesh>\n               {/* Robot arms */}\n-              <mesh position={[size[0] * 0.6, size[1] * 0.2, 0]} castShadow receiveShadow>\n-                <cylinderGeometry args={[0.1, 0.1, size[0] * 0.4]} rotation={[0, 0, Math.PI / 2]} />\n+              <mesh position={[size[0] * 0.6, size[1] * 0.2, 0]} rotation={[0, 0, Math.PI / 2]} castShadow receiveShadow>\n+                <cylinderGeometry args={[0.1, 0.1, size[0] * 0.4]} />\n                 <meshLambertMaterial color=\"#6366f1\" />\n               </mesh>\n               {/* Robot treads */}\n               <mesh position={[0, -size[1] * 0.4, 0]} castShadow>\n@@ -183,10 +183,10 @@\n                 <meshLambertMaterial color={new THREE.Color(vehicleType.color).multiplyScalar(1.2)} />\n               </mesh>\n               {/* Wheels */}\n               {[-size[0] * 0.4, size[0] * 0.4].map((x, i) => (\n-                <mesh key={i} position={[x, -size[1] * 0.4, 0]} castShadow>\n-                  <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} rotation={[Math.PI / 2, 0, 0]} />\n+                <mesh key={i} position={[x, -size[1] * 0.4, 0]} rotation={[Math.PI / 2, 0, 0]} castShadow>\n+                  <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} />\n                   <meshLambertMaterial color=\"#374151\" />\n                 </mesh>\n               ))}\n             </group>\n@@ -208,12 +208,8 @@\n         {/* Level indicator */}\n         <mesh position={[0, size[1] * 0.8, 0]}>\n           <sphereGeometry args={[0.1]} />\n           <meshBasicMaterial color=\"#ffffff\" />\n-          <mesh>\n-            <textGeometry args={[level.toString(), { font: undefined, size: 0.05, height: 0.01 }]} />\n-            <meshBasicMaterial color=\"#000000\" />\n-          </mesh>\n         </mesh>\n       </group>\n     );\n   }\n"
                }
            ],
            "date": 1757743664891,
            "name": "Commit-0",
            "content": "import { forwardRef, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\nexport interface VehicleType {\n  id: string;\n  name: string;\n  purpose: 'delivery' | 'transport' | 'maintenance' | 'collection';\n  speed: number;\n  capacity: number;\n  size: [number, number, number];\n  color: string;\n  maxLevel: number;\n}\n\nexport const VEHICLE_TYPES: Record<string, VehicleType> = {\n  honey_truck: {\n    id: 'honey_truck',\n    name: 'Honey Delivery Truck',\n    purpose: 'delivery',\n    speed: 2,\n    capacity: 100,\n    size: [2, 1, 4],\n    color: '#fbbf24',\n    maxLevel: 5\n  },\n  cargo_drone: {\n    id: 'cargo_drone',\n    name: 'Cargo Drone',\n    purpose: 'transport',\n    speed: 4,\n    capacity: 50,\n    size: [1.5, 0.5, 1.5],\n    color: '#06b6d4',\n    maxLevel: 3\n  },\n  maintenance_bot: {\n    id: 'maintenance_bot',\n    name: 'Maintenance Robot',\n    purpose: 'maintenance',\n    speed: 1,\n    capacity: 20,\n    size: [1, 1, 1],\n    color: '#8b5cf6',\n    maxLevel: 4\n  },\n  honey_collector: {\n    id: 'honey_collector',\n    name: 'Honey Collector',\n    purpose: 'collection',\n    speed: 1.5,\n    capacity: 75,\n    size: [1.5, 1.2, 2],\n    color: '#f59e0b',\n    maxLevel: 6\n  }\n};\n\ninterface VehicleProps {\n  vehicleType: VehicleType;\n  level: number;\n  position: [number, number, number];\n  targetPosition?: [number, number, number];\n  isMoving?: boolean;\n  onReachTarget?: () => void;\n}\n\nexport const Vehicle = forwardRef<THREE.Group, VehicleProps>(\n  ({ vehicleType, level, position, targetPosition, isMoving = false, onReachTarget }, ref) => {\n    const groupRef = useRef<THREE.Group>(null);\n    const currentPos = useRef(new THREE.Vector3(...position));\n    const targetPos = useRef(targetPosition ? new THREE.Vector3(...targetPosition) : null);\n\n    useFrame((state, delta) => {\n      if (isMoving && targetPos.current && groupRef.current) {\n        const direction = targetPos.current.clone().sub(currentPos.current);\n        const distance = direction.length();\n        \n        if (distance > 0.1) {\n          direction.normalize();\n          const moveSpeed = vehicleType.speed * delta;\n          currentPos.current.add(direction.multiplyScalar(moveSpeed));\n          groupRef.current.position.copy(currentPos.current);\n          \n          // Rotate to face movement direction\n          groupRef.current.lookAt(targetPos.current);\n        } else if (onReachTarget) {\n          onReachTarget();\n        }\n      }\n    });\n\n    const sizeMultiplier = 1 + (level - 1) * 0.15;\n    const size: [number, number, number] = [\n      vehicleType.size[0] * sizeMultiplier,\n      vehicleType.size[1] * sizeMultiplier,\n      vehicleType.size[2] * sizeMultiplier\n    ];\n\n    const getVehicleShape = () => {\n      switch (vehicleType.purpose) {\n        case 'delivery':\n          return (\n            <group>\n              {/* Truck body */}\n              <mesh position={[0, 0, 0]} castShadow receiveShadow>\n                <boxGeometry args={[size[0], size[1], size[2] * 0.6]} />\n                <meshLambertMaterial color={vehicleType.color} />\n              </mesh>\n              {/* Truck cab */}\n              <mesh position={[0, size[1] * 0.3, size[2] * 0.3]} castShadow receiveShadow>\n                <boxGeometry args={[size[0] * 0.8, size[1] * 0.6, size[2] * 0.4]} />\n                <meshLambertMaterial color={new THREE.Color(vehicleType.color).multiplyScalar(0.9)} />\n              </mesh>\n              {/* Wheels */}\n              {[-size[0] * 0.4, size[0] * 0.4].map((x, i) =>\n                [-size[2] * 0.25, size[2] * 0.25].map((z, j) => (\n                  <mesh key={`${i}-${j}`} position={[x, -size[1] * 0.4, z]} castShadow>\n                    <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} rotation={[Math.PI / 2, 0, 0]} />\n                    <meshLambertMaterial color=\"#374151\" />\n                  </mesh>\n                ))\n              )}\n            </group>\n          );\n\n        case 'transport':\n          return (\n            <group>\n              {/* Drone body */}\n              <mesh position={[0, 0, 0]} castShadow receiveShadow>\n                <sphereGeometry args={[size[0] * 0.6, 8, 6]} />\n                <meshLambertMaterial color={vehicleType.color} />\n              </mesh>\n              {/* Propellers */}\n              {[[-1, -1], [1, -1], [-1, 1], [1, 1]].map(([x, z], i) => (\n                <group key={i} position={[x * size[0] * 0.8, size[1] * 0.3, z * size[2] * 0.8]}>\n                  <mesh castShadow>\n                    <cylinderGeometry args={[0.05, 0.05, 0.3]} />\n                    <meshLambertMaterial color=\"#374151\" />\n                  </mesh>\n                  <mesh position={[0, 0.2, 0]} castShadow>\n                    <cylinderGeometry args={[size[0] * 0.3, size[0] * 0.3, 0.02]} />\n                    <meshLambertMaterial color=\"#6b7280\" />\n                  </mesh>\n                </group>\n              ))}\n            </group>\n          );\n\n        case 'maintenance':\n          return (\n            <group>\n              {/* Robot body */}\n              <mesh position={[0, 0, 0]} castShadow receiveShadow>\n                <boxGeometry args={size} />\n                <meshLambertMaterial color={vehicleType.color} />\n              </mesh>\n              {/* Robot arms */}\n              <mesh position={[size[0] * 0.6, size[1] * 0.2, 0]} castShadow receiveShadow>\n                <cylinderGeometry args={[0.1, 0.1, size[0] * 0.4]} rotation={[0, 0, Math.PI / 2]} />\n                <meshLambertMaterial color=\"#6366f1\" />\n              </mesh>\n              {/* Robot treads */}\n              <mesh position={[0, -size[1] * 0.4, 0]} castShadow>\n                <boxGeometry args={[size[0] * 1.2, size[1] * 0.2, size[2] * 1.1]} />\n                <meshLambertMaterial color=\"#374151\" />\n              </mesh>\n            </group>\n          );\n\n        case 'collection':\n          return (\n            <group>\n              {/* Collector body */}\n              <mesh position={[0, 0, 0]} castShadow receiveShadow>\n                <boxGeometry args={[size[0], size[1], size[2]]} />\n                <meshLambertMaterial color={vehicleType.color} />\n              </mesh>\n              {/* Collection tank */}\n              <mesh position={[0, size[1] * 0.4, -size[2] * 0.2]} castShadow receiveShadow>\n                <cylinderGeometry args={[size[0] * 0.4, size[0] * 0.4, size[1] * 0.6]} />\n                <meshLambertMaterial color={new THREE.Color(vehicleType.color).multiplyScalar(1.2)} />\n              </mesh>\n              {/* Wheels */}\n              {[-size[0] * 0.4, size[0] * 0.4].map((x, i) => (\n                <mesh key={i} position={[x, -size[1] * 0.4, 0]} castShadow>\n                  <cylinderGeometry args={[size[1] * 0.3, size[1] * 0.3, 0.2]} rotation={[Math.PI / 2, 0, 0]} />\n                  <meshLambertMaterial color=\"#374151\" />\n                </mesh>\n              ))}\n            </group>\n          );\n\n        default:\n          return (\n            <mesh position={[0, 0, 0]} castShadow receiveShadow>\n              <boxGeometry args={size} />\n              <meshLambertMaterial color={vehicleType.color} />\n            </mesh>\n          );\n      }\n    };\n\n    return (\n      <group ref={groupRef} position={position}>\n        {getVehicleShape()}\n        {/* Level indicator */}\n        <mesh position={[0, size[1] * 0.8, 0]}>\n          <sphereGeometry args={[0.1]} />\n          <meshBasicMaterial color=\"#ffffff\" />\n          <mesh>\n            <textGeometry args={[level.toString(), { font: undefined, size: 0.05, height: 0.01 }]} />\n            <meshBasicMaterial color=\"#000000\" />\n          </mesh>\n        </mesh>\n      </group>\n    );\n  }\n);\n\nVehicle.displayName = 'Vehicle';\n\n// Component that takes vehicleType as string ID\ninterface VehicleComponentProps {\n  vehicleType: string;\n  position: [number, number, number];\n  level?: number;\n  isMoving?: boolean;\n}\n\nexport function VehicleComponent({ vehicleType, position, level = 1, isMoving = false }: VehicleComponentProps) {\n  const vehicleTypeObj = getVehicleTypeById(vehicleType);\n  \n  if (!vehicleTypeObj) {\n    console.warn(`Vehicle type \"${vehicleType}\" not found`);\n    return null;\n  }\n  \n  return <Vehicle vehicleType={vehicleTypeObj} position={position} level={level} isMoving={isMoving} />;\n}\n\nexport function getVehicleTypeById(id: string): VehicleType | null {\n  return VEHICLE_TYPES[id] || null;\n}\n\nexport function getVehiclesByPurpose(purpose: VehicleType['purpose']): VehicleType[] {\n  return Object.values(VEHICLE_TYPES).filter(vehicle => vehicle.purpose === purpose);\n}\n"
        }
    ]
}